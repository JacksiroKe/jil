// Lex for C++
// Last update: 2014-07-17

lex = (
    // Quote
    { id = "comment"; quote = [ "/*", "*/" ]; flags = "multi_line"; },
    { id = "comment"; quote = [ "//" ]; flags = "escape_eol"; },
    { id = "constant.string"; quote = [ "\"", "\"" ]; flags = "escape_eol"; },
    { id = "constant.char"; quote = [ "'", "'" ]; },

    // Anyof
    { id = "constant.bool"; anyof = "true false"; },
    { id = "constant.null"; anyof = "NULL"; },
    // Vim takes 'this' as statement.
    //{ id = "identifier"; anyof = "this"; },
    { id = "statement"; anyof = "break continue default goto return this using typedef"; },
    { id = "statement.conditional"; anyof = "if else switch case"; },
    { id = "statement.repeat"; anyof = "for do while"; },
    { id = "statement.exception"; anyof = "try catch throw"; },
    { id = "statement.operator"; anyof = "sizeof new delete"; },
    { id = "type"; anyof = "void bool char short int long float double signed unsigned size_t wchar_t operator typeid"; },
    { id = "type"; anyof = "static_cast dynamic_cast const_cast reinterpret_cast"; },
    { id = "type.qualifier"; anyof = "auto static register extern const explicit volatile mutable typename virtual public protected private friend inline"; },
    { id = "type.struct"; anyof = "class enum namespace struct union template"; },
    // C++11
    { id = "constant"; anyof = "nullptr"; },
    { id = "type.qualifier"; anyof = "override final constexpr decltype"; },
    { id = "statement.exception"; anyof = "noexcept"; },

    // Regex
    { id = "preproc"; regex = "#\s*ifdef\b"; },
    { id = "preproc"; regex = "#\s*ifndef\b"; },
    { id = "preproc"; regex = "#\s*if\s+!?\s*defined\b"; },
    { id = "preproc"; regex = "#\s*if\b"; },
    { id = "preproc"; regex = "#\s*elif\s+!?\s*defined\b"; },
    { id = "preproc"; regex = "#\s*elif\b"; },
    { id = "preproc"; regex = "#\s*else\b"; },
    { id = "preproc"; regex = "#\s*define\b"; },
    { id = "preproc"; regex = "#\s*endif\b"; },
    { id = "preproc"; regex = "#\s*include\s*\".+\""; },
    { id = "preproc"; regex = "#\s*include\s*<.+>"; },
    { id = "preproc"; regex = "#\s*include\b"; },
    { id = "preproc"; regex = "#\s*pragma\b"; },

    { id = "constant.number"; regex = "[1-9][0-9]*[Ll]?[Uu]?"; }, // Decimal
    // Order matters:
    // - Put Hex before Octal.
    // - Put Exponential before Simple.
    { id = "constant.number"; regex = "0[Xx][[:xdigit:]]*[Ll]?[Uu]?"; }, // Hex
    { id = "constant.number"; regex = "0[0-7]*[Ll]?[Uu]?"; }, // Octal
    { id = "constant.number"; regex = "(\d+|\d+\.|\d+\.\d+|\.\d+)[Ee][\+-]?\d+[LlFf]?"; }, // Exponential float
    { id = "constant.number"; regex = "(\d+\.|\d+\.\d+|\.\d+)[LlFf]?"; } // Simple float
);
