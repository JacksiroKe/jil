// Lex for C
// Last update: 2014-12-01

lex = (
    // Quote
    { id = "comment"; quote = [ "/*", "*/" ]; multi_line = true; },
    { id = "constant.string"; quote = [ "\"", "\"" ]; escape_eol= true; },
    { id = "constant.char"; quote = [ "'", "'" ]; },

    // Anyof
    { id = "statement"; anyof = "break continue default goto return typedef"; },
    { id = "statement.conditional"; anyof = "if else switch case"; },
    { id = "statement.repeat"; anyof = "for do while"; },
    { id = "statement.operator"; anyof = "sizeof"; },
    { id = "type"; anyof = "void char short int long float double signed unsigned wchar_t"; },
    { id = "type.qualifier"; anyof = "auto static register extern const volatile mutable"; },
    { id = "type.struct"; anyof = "enum struct union"; },

    // Regex
    { id = "preproc"; regex = "#\s*ifdef\b"; },
    { id = "preproc"; regex = "#\s*ifndef\b"; },
    { id = "preproc"; regex = "#\s*if\s+!?\s*defined\b"; },
    { id = "preproc"; regex = "#\s*if\b"; },
    { id = "preproc"; regex = "#\s*elif\s+!?\s*defined\b"; },
    { id = "preproc"; regex = "#\s*elif\b"; },
    { id = "preproc"; regex = "#\s*else\b"; },
    { id = "preproc"; regex = "#\s*define\b"; },
    { id = "preproc"; regex = "#\s*endif\b"; },
    { id = "preproc"; regex = "#\s*include\s*\".+\""; },
    { id = "preproc"; regex = "#\s*include\s*<.+>"; },
    { id = "preproc"; regex = "#\s*include\b"; },
    { id = "preproc"; regex = "#\s*pragma\b"; },

    { id = "constant.number"; regex = "[1-9][0-9]*[Ll]?[Uu]?"; }, // Decimal
    // Order matters:
    // - Put Hex before Octal.
    // - Put Exponential before Simple.
    { id = "constant.number"; regex = "0[Xx][[:xdigit:]]*[Ll]?[Uu]?"; }, // Hex
    { id = "constant.number"; regex = "0[0-7]*[Ll]?[Uu]?"; }, // Octal
    { id = "constant.number"; regex = "(\d+|\d+\.|\d+\.\d+|\.\d+)[Ee][\+-]?\d+[LlFf]?"; }, // Exponential float
    { id = "constant.number"; regex = "(\d+\.|\d+\.\d+|\.\d+)[LlFf]?"; } // Simple float
);
